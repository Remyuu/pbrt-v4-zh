#import "../template.typ": parec, ez_caption

== Sampling Using the Inversion Method
<Sampling-Using-the-Inversion-Method>

#parec[
  To evaluate the Monte Carlo estimator in @eqt:MC-estimator, it is necessary to be able to draw random samples from a chosen probability distribution. There are a variety of techniques for doing so, but one of the most important for rendering is the #emph[inversion method];, which maps uniform samples from $\[ 0 , 1 \)$ to a given 1D probability distribution by inverting the distribution's CDF. (In @sampling-with-multidimensional-transformations we will see how this approach can be applied to higher-dimensional functions by considering a sequence of 1D distributions.) When used with well-distributed samples such as those generated by the samplers that are defined in Chapter 8, the inversion method can be particularly effective. Throughout the remainder of the book, we will see the application of the inversion method to generate samples from the distributions defined by BSDFs, light sources, cameras, and scattering media.
][
  为了评估@eqt:MC-estimator 中的蒙特卡洛估计量，必须能够从选定的概率分布中抽取随机样本。有多种技术可以实现这一点，但在渲染领域，最重要的方法之一是#emph[逆变换方法];，它通过反转分布的累积分布函数（CDF）将 $\[ 0 , 1 \)$ 中的均匀样本映射到给定的 1D 概率分布。（在@sampling-with-multidimensional-transformations 中，我们将看到如何通过考虑一系列 1D 分布将这种方法应用于更高维的函数。）当与第 8 章中定义的采样器生成的高质量样本一起使用时，逆变换方法可以特别有效。在本书的其余部分，我们将看到逆变换方法应用于对 BSDFs、光源、相机和散射介质定义进行采样。
]

=== Discrete Case

#parec[
  @eqt:sampling-discrete-random leads to an algorithm for sampling from a set of discrete probabilities using a uniform random variable. Suppose we have a process with four possible outcomes where the probabilities of each of the four outcomes are given by $p_1$, $p_2$, $p_3$, and $p_4$, with $sum_i p_i = 1$. The corresponding PMF is shown in Figure 2.3.
][
  @eqt:sampling-discrete-random 导出了使用均匀随机变量从一组离散概率中采样的算法。假设我们有一个具有四种可能结果的过程，其中每种结果的概率分别为 $p_1$ 、 $p_2$ 、 $p_3$ 和 $p_4$，且 $sum_i p_i = 1$。相应的 PMF 如图 2.3 所示。
]


#figure(
  image("../pbr-book-website/4ed/Monte_Carlo_Integration/discrete-pdf.svg", width: 50%),
  caption: [
    #ez_caption[
      A PMF for Four Events, Each with a Probability $p_i$ . The sum of their probabilities $sum_i p_i$ is necessarily 1.
    ][
      四个事件的概率质量函数（PMF），每个事件具有概率 $p_i$。它们的概率总和 $sum_i p_i$ 必须为 1。
    ]
  ],
) <discrete-pdf>


#parec[
  There is a direct connection between the sums in Equation (2.2) and the definition of the CDF. The discrete CDF is given by
][
  方程 (2.2) 中的和与 CDF 的定义之间有直接联系。离散 CDF 由下式给出：
]

$ P_i = sum_(j = 1)^i p_j, $

#parec[
  which can be interpreted graphically by stacking the bars of the PMF on top of each other, starting at the left. This idea is shown in Figure 2.4.
][
  这可以通过从左侧开始堆叠 PMF 的条形图来图形化解释。这一想法如图 2.4 所示。
]


#figure(
  image("../pbr-book-website/4ed/Monte_Carlo_Integration/discrete-cdf.svg", width: 50%),
  caption: [
    #parec[
      A Discrete CDF, Corresponding to the PMF in Figure 2.3. Each column's height is given by the PMF for the event that it represents plus the sum of the PMFs for the previous events, $P_i = sum_(j=1)^i p_j$.
    ][
      离散累计分布函数 (CDF)，对应于图 2.3 中的概率质量函数 (PMF)。每一列的高度由它所代表事件的 PMF 决定，加上之前事件的 PMF 之和，$P_i = sum_(j=1)^i p_j$。
    ]
  ],
) <discrete-cdf>

#parec[
  The sampling operation of Equation (2.2) can be expressed as finding $i$ such that
][
  方程 (2.2) 的采样操作可以表示为找到满足以下条件的 $i$ ：
]

$ P_(i - 1) lt.eq xi < P_i, $

#parec[
  which can be interpreted as inverting the CDF $P$, and thus, the name of the technique. Continuing the graphical interpretation, this sampling operation can be considered in terms of projecting the events' probabilities onto the vertical axis where they cover the range $[0 , 1]$ and using a random variable $xi$ to select among them (see Figure 2.5). It should be clear that this draws from the correct distribution—the probability of the uniform sample hitting any particular bar is exactly equal to the height of that bar.
][
  这可以解释为反转 CDF $P$，因此，该技术的名称。继续图形化解释，这个采样操作可以考虑为将事件的概率投影到垂直轴上，覆盖范围 $[0 , 1]$，并使用随机变量 $xi$ 在其中选择（见图 2.5）。应该清楚的是，这从正确的分布中抽取样本——均匀样本击中任何特定条的概率正好等于该条的高度。
]


#parec[
  The `SampleDiscrete()` function implements this algorithm. It takes a not-necessarily normalized set of nonnegative weights, a uniform random sample `u`, and returns the index of one of the weights with probability proportional to its weight. The sampling operation it performs corresponds to finding $i$ such that
][
  `SampleDiscrete()` 函数实现了这个算法。它接受一组非归一化的非负权重、一个均匀随机样本 `u`，并返回其中一个权重的索引，其概率与权重成比例。它执行的采样操作对应于找到满足以下条件的 $i$ ：
]

$ sum_(j = 1)^(i - 1) w_j lt.eq xi sum_(w_i) < sum_(j = 1)^i w_j, $

#parec[
  which corresponds to multiplying Equation (2.19) by $sum_(w_i)$.(Not requiring a normalized PMF is a convenience for calling code and not much more work in the function's implementation.) Two optional parameters are provided to return the value of the PMF for the sample as well as a new uniform random sample that is derived from `u`.
][
  这对应于将方程 (2.19) 乘以 $sum_(w_i)$。（不需要归一化的 PMF 是为了调用代码的方便，并且在函数的实现中并没有增加太多工作。）提供了两个可选参数，以返回样本的 PMF 值以及从 `u` 派生的新均匀随机样本。
]



#parec[
  This function is designed for the case where only a single sample needs to be generated from the weights' distribution; if multiple samples are required, the `AliasTable`, which will be introduced in Section A.1, should generally be used instead: it generates samples in $O (1)$ time after an $O (n)$ preprocessing step, whereas `SampleDiscrete()` requires $O (n)$ time for each sample generated.
][
  这个函数设计用于仅需要从权重分布生成单个样本的情况；如果需要多个样本，通常应该使用第 A.1 节中介绍的 `AliasTable`：它在 $O (n)$ 预处理步骤后以 $O (1)$ 时间生成样本，而 `SampleDiscrete()` 每次生成样本都需要 $O (n)$ 时间。
]

```cpp
int SampleDiscrete(pstd::span<const Float> weights, Float u, Float *pmf, Float *uRemapped) {
    if (weights.empty()) {
        if (pmf)
            *pmf = 0;
        return -1;
    }
    Float sumWeights = 0;
    for (Float w : weights)
        sumWeights += w;
    Float up = u * sumWeights;
    if (up == sumWeights)
        up = NextFloatDown(up);
    int offset = 0;
    Float sum = 0;
    while (sum + weights[offset] <= up)
        sum += weights[offset++];
    if (pmf)
        *pmf = weights[offset] / sumWeights;
    if (uRemapped)
        *uRemapped = std::min((up - sum) / weights[offset], OneMinusEpsilon);
    return offset;
}
```


#parec[
  The case of `weights` being empty is handled first so that subsequent code can assume that there is at least one weight.
][
  首先处理 `weights` 为空的情况，以便后续代码可以假设至少有一个权重。
]



#parec[
  The discrete probability of sampling the `i`th element is given by `weights[i]` divided by the sum of all weight values. Therefore, the function computes that sum next.
][
  采样第 `i` 个元素的离散概率由 `weights[i]` 除以所有权重值的总和给出。因此，函数接下来计算该总和。
]



#parec[
  Following Equation (2.20), the uniform sample `u` is scaled by the sum of the weights to get a value $u'$ that will be used to sample from them. Even though the provided `u` value should be in the range $[0, 1)$, it is possible that `u * sumWeights` will be equal to `sumWeights` due to floating-point round-off. In that rare case,`up` is bumped down to the next lower floating-point value so that subsequent code can assume that `up < sumWeights`.
][
  根据方程 (2.20)，均匀样本 `u` 通过权重总和进行缩放，得到一个值 $u'$，用于从这些权重中采样。尽管提供的 `u` 值应在范围 $[0, 1)$ 内，但由于浮点舍入，`u * sumWeights` 可能等于 `sumWeights`。在这种罕见情况下，`up` 被降低到下一个较低的浮点值，以便后续代码可以假设 `up < sumWeights`。
]



#parec[
  We would now like to find the last offset in the weights array $i$ where the random sample `up` is greater than the sum of weights up to $i$. Sampling is performed using a linear search from the start of the array, accumulating a sum of weights until the sum would be greater than $u'$.
][
  我们现在希望找到权重数组 $i$ 中的最后一个偏移量，其中随机样本 `up` 大于 $i$ 之前的权重总和。采样使用从数组开始进行的线性搜索，累积权重总和，直到总和大于 $u'$。
]



#parec[
  After the `while` loop terminates, the randomness in the provided sample `u` has only been used to select an element of the array—a discrete choice. The offset of a sample between the CDF values that bracket it is itself a uniform random value that can easily be remapped to $[0, 1)$. This value is returned to the caller in `uRemapped`, if requested.
][
  `while` 循环结束后，提供的样本 `u` 中的随机性仅用于选择数组中的一个元素——一个离散选择。样本在夹住它的 CDF 值之间的偏移量本身是一个均匀随机值，可以很容易地重新映射到 $[0, 1)$。如果请求，这个值在 `uRemapped` 中返回给调用者。
]



#parec[
  One might ask: why bother? It is not too difficult to generate uniform random variables, so the benefit of providing this option may seem marginal. However, for some of the high-quality sample generation algorithms in Chapter 8, it can be beneficial to reuse samples in this way rather than generating new ones—thus, this option is provided.
][
  有人可能会问：为什么要费心这样做？生成均匀随机变量并不太困难，因此提供这个选项的好处可能看起来不大。然而，对于第 8 章中的一些高质量样本生成算法，以这种方式重用样本而不是生成新的样本可能是有益的——因此，提供了这个选项。
]


#figure(
  image("../pbr-book-website/4ed/Monte_Carlo_Integration/discrete-inversion.svg", width: 70%),
  caption: [

    #parec[
      Figure 2.5: To use the inversion method to draw a sample from the distribution described by the PMF in Figure 2.3, a canonical uniform random variable is plotted on the vertical axis. By construction, the horizontal extension of $\xi$ will intersect the box representing the $i$th outcome with probability $p_i$. If the corresponding event is chosen for a set of random variables $\xi$, then the resulting distribution of events will be distributed according to the PMF.
    ][
      图 2.5：要使用逆变换方法从图 2.3 中的 PMF 描述的分布中抽取样本，将一个规范的均匀随机变量绘制在垂直轴上。通过构造，$\xi$ 的水平延伸将以概率 $p_i$ 与表示第 $i$ 个结果的框相交。如果为一组随机变量 $\xi$ 选择了相应的事件，那么事件的结果分布将按照 PMF 分布。
    ]

  ],
) <discrete-inversion>


=== Continuous Case
<continuous-case>

#parec[
  In order to generalize this technique to continuous distributions, consider what happens as the number of discrete possibilities approaches infinity. The PMF from Figure 2.3 becomes a PDF, and the CDF from Figure 2.4 becomes its integral. The projection process is still the same, but it has a convenient mathematical interpretation—it represents inverting the CDF and evaluating the inverse at $xi_i$.
][
  为了将这种技术推广到连续分布，考虑离散可能性数量趋近无穷时的情况。图2.3中的概率质量函数（PMF）变成了概率密度函数（PDF），图2.4中的累积分布函数（CDF）变成了它的积分。投影过程仍然是相同的，但它有一个方便的数学解释——它表示反转CDF并在 $xi_i$ 处求其反函数的值。
]



#parec[
  More precisely, we can draw a sample $X_i$ from a PDF $p (x)$ with the following steps:
][
  更准确地说，我们可以从PDF $p (x)$ 中抽取一个样本 $X_i$，步骤如下：
]



#parec[
  1. Integrate the PDF to find the CDF $P(x) = integral_0^x p(x') d x'$.
][
  1. 对PDF进行积分以找到CDF $P(x) = integral_0^x p(x') d x'$。
]

#parec[
  2. Obtain a uniformly distributed random number $xi$.
][
  2. 获取一个均匀分布的随机数$xi$。
]

#parec[
  3. Generate a sample by solving $xi = P (X)$ for $X$; in other words, find $X = P^(- 1) (xi)$.
][
  3. 通过求解$xi = P (X)$生成样本；换句话说，找到$X = P^(- 1) (xi)$。
]



#parec[
  We will illustrate this algorithm with a simple example; see Section A.4 for its application to a number of additional functions.
][
  我们将通过一个简单例子说明此算法；更多应用示例请参见第A.4节。
]



=== Sampling a Linear Function



#parec[
  The function $f (x) = (1 - x) a + x b$ defined over $[0 , 1]$ linearly interpolates between $a$ at $x = 0$ and $b$ at $x = 1$. Here we will assume that $a , b gt.eq 0$ ; an exercise at the end of the chapter discusses the more general case.
][
  在区间 $[0 , 1]$ 上定义的函数 $f (x) = (1 - x) a + x b$ 在 $x = 0$ 处为 $a$，在 $x = 1$ 处为 $b$，进行线性插值。此处我们假设 $a , b gt.eq 0$ ；更一般的情况在本章末尾的练习中讨论。
]

```cpp
Float Lerp(Float x, Float a, Float b) {
    return (1 - x) * a + x * b;
}
```

#parec[
  The function's integral is $integral_0^1 f(x) d x = frac(a + b, 2)$, which gives the normalization constant $frac(2, a + b)$ to define its PDF,
][
  该函数的积分为 $integral_0^1 f(x) d x = frac(a + b, 2)$，这给出了归一化常数 $frac(2, a + b)$ 用于定义其概率密度函数 (PDF)。
]
$
  p(x) = frac(2 f(x), a + b) .
$

```cpp
Float LinearPDF(Float x, Float a, Float b) {
    if (x < 0 || x > 1)
        return 0;
    return 2 * Lerp(x, a, b) / (a + b);
}
```


#parec[
  Integrating the PDF gives the CDF, which is the quadratic function
][
  对PDF进行积分得到CDF，这是一个二次函数
]


$
  P(x) = frac(x(a(2 - x) + b x), a + b) .
$


#parec[
  Inverting $xi = P(X)$ gives a sampling recipe
][
  反转 $xi = P(X)$ 得到采样配方
]


$
  X = frac(a - sqrt((1 - xi) a^2 + xi b^2), a - b),
$


#parec[
  though note that in this form, the case $a = b$ gives an indeterminate result. The more stable formulation
][
  但请注意，此形式下 $a = b$ 的情况会导致不确定结果。更稳定的公式
]



$
  X = frac(xi(a + b), a + sqrt((1 - xi) a^2 + xi b^2))
$



#parec[
  computes the same result and is implemented here.
][
  计算相同结果，并在此处实现。
]

```cpp
Float SampleLinear(Float u, Float a, Float b) {
    if (u == 0 && a == 0) return 0;
    Float x = u * (a + b) / (a + std::sqrt(Lerp(u, Sqr(a), Sqr(b))));
    return std::min(x, OneMinusEpsilon);
}
```


#parec[
  One detail to note is the `std::min` call in the return statement, which ensures that the returned value is within the range $[0, 1)$. Although the sampling algorithm generates values in that range given $xi in [0, 1)$, round-off error may cause the result to be equal to 1. Because some of the code that calls the sampling routines depends on the returned values being in the specified range, the sampling routines must ensure this is so.
][
  需注意的是返回语句中的`std::min`调用，确保返回值在区间 $[0, 1)$ 内。尽管采样算法在给定 $xi in [0, 1)$ 的情况下在该范围内生成值，但舍入误差可能导致结果等于1。因为调用采样例程的一些代码依赖于返回值在指定范围内，所以采样例程必须确保这一点。
]



#parec[
  In addition to providing functions that sample from a distribution and compute the PDF of a sample,`pbrt` usually also provides functions that invert sampling operations, returning the random sample $\xi$ that corresponds to a value $x$. In the 1D case, this is equivalent to evaluating the CDF.
][
  除了提供从分布中采样和计算样本PDF的函数外，`pbrt`通常还提供反转采样操作的函数，返回对应于值 $x$ 的随机样本 $xi$。在一维情况下，这相当于评估CDF。
]

```cpp
Float InvertLinearSample(Float x, Float a, Float b) {
    return x * (a * (2 - x) + b * x) / (a + b);
}
```

