#import "../template.typ": parec, ez_caption

== Diffuse Reflection
#parec[
  One of the simplest BRDFs is the Lambertian model, which describes a perfect diffuse surface that scatters incident illumination equally in all directions. It is a reasonable approximation to many real-world surfaces such as paper or matte paint. The Lambertian model captures the behavior of such diffuse materials relatively well, though the approximation tends to perform worse for light arriving at a grazing angle, where specular reflection causes a noticeable deviation from uniformity. (Microfacet models such as those presented in @roughness-using-microfacet-theory can account for such effects.)
][
  最简单的双向反射分布函数（BRDF）之一是Lambertian模型，它描述了一个完美的漫反射表面，能够将入射光线均匀地散射到所有方向。这个模型是对许多现实世界表面（如纸张或哑光漆）的合理近似。Lambertian模型相对较好地捕捉了这些漫反射材料的行为，尽管这种近似在光线以掠射角度入射时表现得较差，此时镜面反射会引起从均匀性上的明显偏差。（例如@roughness-using-microfacet-theory 中介绍的微面模型可以解释这种效应。）
]
#parec[
  It is interesting to note that surfaces created from polytetrafluoroethylene (PTFE) powder are known to be particularly good Lambertian reflectors. They are commonly used to calibrate laboratory equipment for this reason.
][
  值得注意的是，由聚四氟乙烯（PTFE）粉末制成的表面被认为是特别好的Lambertian反射器。正因为如此，它们通常用于校准实验室设备。
]
```cpp
<<DiffuseBxDF Definition>>=
class DiffuseBxDF {
  public:
    <<DiffuseBxDF Public Methods>>
  private:
    SampledSpectrum R;
};
```
#parec[
  The constructor takes a reflectance spectrum `R` with values in the range that specify the fraction of incident light that is scattered.
][
  构造函数接受一个反射光谱 `R`，其值范围指定了被散射的入射光的比例。
]

```cpp
<<DiffuseBxDF Public Methods>>=
DiffuseBxDF(SampledSpectrum R) : R(R) {}
```
#parec[
  The reflection distribution function is just a constant, though it requires a normalization factor equal to $1\/pi$, so that the total integrated reflectance equals $R$.
][
  反射分布函数只是一个常数函数，但它需要 $1\/pi$ 的归一化因子，以使反射率的积分等于 $R$。
]

$
  integral_(H^2 lr((n))) f_r lr((p comma omega_o comma omega prime)) cos theta prime d omega prime eq integral_0^(2 pi) integral_0^(pi / 2) R / pi cos theta prime sin theta prime d theta prime d phi.alt prime eq R dot.basic
$

#parec[
  With this correction, the `f()` implementation is given by
][
  有了这个修正，`f()` 实现如下所示
]
```cpp
<<DiffuseBxDF Public Methods>>+=
SampledSpectrum f(Vector3f wo, Vector3f wi, TransportMode mode) const {
    if (!SameHemisphere(wo, wi))
        return SampledSpectrum(0.f);
    return R * InvPi;
}
```

#parec[
  The sampling function returns an invalid sample if the caller specified that reflection components of the `BSDF` should not be sampled. Otherwise, it draws a direction from a suitable distribution and returns all the sample-related information via a `BSDFSample` instance.
][
  采样函数在调用者指定不应采样`BSDF`的标志时返回无效样本。否则，它会从适当的分布中抽取一个方向，并通过`BSDFSample`实例返回所有与样本相关的信息。
]
```cpp
<<DiffuseBxDF Public Methods>>+=
pstd::optional<BSDFSample> Sample_f(
        Vector3f wo, Float uc, Point2f u, TransportMode mode,
        BxDFReflTransFlags sampleFlags = BxDFReflTransFlags::All) const {
    if (!(sampleFlags & BxDFReflTransFlags::Reflection))
        return {};
    <<Sample cosine-weighted hemisphere to compute wi and pdf>>
    return BSDFSample(R * InvPi, wi, pdf, BxDFFlags::DiffuseReflection);
}
```

#parec[
  Working in a canonical reflection coordinate system greatly simplifies the central sampling step: in particular, a direction generated by `SampleCosineHemisphere()` can be directly used, and we must only pay attention that wo and wi lie in the same hemisphere, as indicated by `wo.z` and `wi.z`.
][
  规范化的反射坐标系统大大简化了核心采样步骤：特别是，方向可以直接使用`SampleCosineHemisphere()`生成的，我们只需注意`wo`和`wi`位于同一半球，如`wo.z`和`wi.z`所示。
]

#parec[
  Although the Lambertian BRDF is uniform over the hemisphere, BSDFs are sampled in the context of the light transport equation, (@eqt:rendering-equation), where the BSDF is multiplied by the incident radiance and a cosine factor. It is worthwhile for BxDFs to include the cosine factor in their sampling distribution if possible; see @fig:lambertian-unif-vs-cosine, which compares uniform and cosine-weighted hemisphere sampling for the DiffuseBxDF.
][
  尽管Lambertian BRDF在半球上是均匀的，但BSDF在光传输方程（@eqt:rendering-equation）的上下文中进行采样，其中BSDF乘以入射辐射和一个余弦因子。如果可能的话，`BxDF`在其采样分布中包含余弦因子是有价值的；见@fig:lambertian-unif-vs-cosine，它比较了`DiffuseBxDF`的均匀和余弦加权半球采样。
]



#figure(
  table(
    stroke: none,
    columns: 2, // 2 means 2 auto-sized columns
    gutter: 2mm, // space between columns
    [(a) Uniform hemisphere], [(b) Cosine hemisphere],
    [#image("../pbr-book-website/4ed/Reflection_Models/dragon-lambertian-uniform.png")],
    [#image("../pbr-book-website/4ed/Reflection_Models/dragon-lambertian-cosine.png")],
  ),
  caption: [
    #ez_caption[
      Comparison of Sampling Methods for a Lambertian BSDF. Both images are rendered using 4 samples per pixel. (a) Uniform hemisphere sampling. (b) Cosine-weighted hemisphere sampling. By incorporating the cosine factor in the light transport equation’s integrand, cosine-weighted hemisphere sampling improves mean squared error (MSE) by a factor of 2.34 for this test scene, without additional computational cost.
    ][
      Lambertian BSDF采样方法的比较。两幅图像都使用每像素4个样本进行渲染。（a）均匀半球采样。（b）余弦加权半球采样。通过在光传输方程的
      被积函数中加入余弦因子，余弦加权半球采样在这个测试场景中将均方误差（MSE）降低了2.34倍，而不增加额外的计算成本。
    ]
  ],
  kind: image,
)<lambertian-unif-vs-cosine>

```cpp
<<Sample cosine-weighted hemisphere to compute wi and pdf>>=
Vector3f wi = SampleCosineHemisphere(u);
if (wo.z < 0) wi.z *= -1;
Float pdf = CosineHemispherePDF(AbsCosTheta(wi));
```
#parec[
  The `PDF()` method just needs to ensure that the caller has included reflection in the types of scattering that it is interested in and that the two directions both lie in the same hemisphere.
][
  `PDF()` 方法只需要确保调用者已经包括反射在其感兴趣的散射类型中，并且两个方向都位于同一半球。
]
```cpp
<<DiffuseBxDF Public Methods>>+=
Float PDF(Vector3f wo, Vector3f wi, TransportMode mode,
          BxDFReflTransFlags sampleFlags = BxDFReflTransFlags::All) const {
    if (!(sampleFlags & BxDFReflTransFlags::Reflection) ||
        !SameHemisphere(wo, wi))
        return 0;
    return CosineHemispherePDF(AbsCosTheta(wi));
}
```
